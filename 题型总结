1. Next Greater Element

739 - daily temperature, Next Greater Element I

1). Using Stack and HashMap 
if a new item is greater than the top value, put that in a hashmap 
if not, place on top of the Stack
hashmap stores the next greater element for each element

2. for Matrix problem [BFS]

Maze, Number of Island

1). set up an object
2). build visited boolean array
3). build direction array
4). build a queue
5). use queue template to do

3. clone graph / Clone N-ary Tree 

BFS Method:
1). create a visited hashmap (node, cloneNode)
2). create a queue to store all nodes
3). iterate through all neighbors, if visited hashmap contains this nei, put that in the children list that the clone node has; if not, create a clone node of this neighbor node

Do the BFS traversal.

Pop a node from the front of the queue.
Visit all the neighbors of this node.
If any of the neighbors was already visited then it must be present in the visited dictionary. Get the clone of this neighbor from visited in that case.
Otherwise, create a clone and store in the visited.
Add the clones of the neighbors to the corresponding list of the clone node.

DFS Template I:
/*
 * Return true if there is a path from cur to target.
 */
boolean DFS(Node cur, Node target, Set<Node> visited) {
    return true if cur is target;
    for (next : each neighbor of cur) {
        if (next is not in visited) {
            add next to visted;
            return true if DFS(next, target, visited) == true;
        }
    }
    return false;
}

DFS Template II with Stack
/*
 * Return true if there is a path from cur to target.
 */
boolean DFS(int root, int target) {
    Set<Node> visited;
    Stack<Node> stack;
    add root to stack;
    while (s is not empty) {
        Node cur = the top element in stack;
        remove the cur from the stack;
        return true if cur is target;
        for (Node next : the neighbors of cur) {
            if (next is not in visited) {
                add next to visited;
                add next to stack;
            }
        }
    }
    return false;
}

4. backtracking

explore neighbors
backtrack()
place() on to the path
remove() from the path when it reaches the end or there is no way to go further


for subset type questions we use backtrack template

using for loop to get the candidate
and path.addLast(), backtrack(), and removeLast

5. gcd function
   public int gcd(int a, int b) {
        if(b == 0){
            return a;
        }
        return gcd(b, a % b);
    }

public String gcdOfStrings(String str1, String str2) {
	
		//Ensure that str1 is greater than str2
        if(str2.length() > str1.length())
            return gcdOfStrings(str2, str1);
			
        //If str2 is length 0, return str1;
        if(str2.length() == 0)
            return str1;

		/* 
            Calculate the remainder by:
            1. Checking to see if str1 starts with str2. 
                If it doesn't then return the empty string. i.e. the string LEET, CODE 
            2. Calculate the remainder substring. 
            3. Recursively call with str2 and the remainder. 
		*/ 
        String remainder = "";
        if(str1.startsWith(str2)) {
            int remainder_loc = str1.indexOf(str2) + str2.length();
            remainder = str1.substring(remainder_loc);
        } else {
            return "";
        }
        return gcdOfStrings(str2, remainder);
    }

